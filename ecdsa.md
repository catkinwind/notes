# Elliptic Curve Digital Signature Algorithm
check: https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm
## Signature generate algorithm
Suppose Alice want to send a signed message to Bob. Initially, they must agree on the curve parameters (CURVE, G, n).
- CURVE: the elliptic curve field and equation used
- G: elliptic curve base point, a generator of the elliptic curve with large prime order n.
- n: integer order of G, means that n X G = 0

Alice creates a key pair, consisting of a private key integer d\_{A}, randomly selected in the interval {\displaystyle [1,n-1]} [1,n-1]; and a public key curve point {\displaystyle Q_{A}=d_{A}\times G} Q_{A}=d_{A}\times G. We use {\displaystyle \times } \times  to denote elliptic curve point multiplication by a scalar.

For Alice to sign a message {\displaystyle m} m, she follows these steps:

Calculate {\displaystyle e={\textrm {HASH}}(m)} e={\textrm {HASH}}(m), where HASH is a cryptographic hash function, such as SHA-2.
Let {\displaystyle z} z be the {\displaystyle L_{n}} L_{n} leftmost bits of {\displaystyle e} e, where {\displaystyle L_{n}} L_{n} is the bit length of the group order {\displaystyle n} n.
Select a cryptographically secure random integer {\displaystyle k} k from {\displaystyle [1,n-1]} [1,n-1].
Calculate the curve point {\displaystyle (x_{1},y_{1})=k\times G} (x_{1},y_{1})=k\times G.
Calculate {\displaystyle r=x_{1}\,{\bmod {\,}}n} r=x_{1}\,{\bmod {\,}}n. If {\displaystyle r=0} r=0, go back to step 3.
Calculate {\displaystyle s=k^{-1}(z+rd_{A})\,{\bmod {\,}}n} s=k^{-1}(z+rd_{A})\,{\bmod {\,}}n. If {\displaystyle s=0} s=0, go back to step 3.
The signature is the pair {\displaystyle (r,s)} (r,s).
When computing {\displaystyle s} s, the string {\displaystyle z} z resulting from {\displaystyle {\textrm {HASH}}(m)} {\textrm {HASH}}(m) shall be converted to an integer. Note that {\displaystyle z} z can be greater than {\displaystyle n} n but not longer.[1]

As the standard notes, it is crucial to select different {\displaystyle k} k for different signatures, otherwise the equation in step 6 can be solved for {\displaystyle d_{A}} d_{A}, the private key: Given two signatures {\displaystyle (r,s)} (r,s) and {\displaystyle (r,s')} (r,s'), employing the same unknown {\displaystyle k} k for different known messages {\displaystyle m} m and {\displaystyle m'} m', an attacker can calculate {\displaystyle z} z and {\displaystyle z'} z', and since {\displaystyle s-s'=k^{-1}(z-z')} s-s'=k^{-1}(z-z') (all operations in this paragraph are done modulo {\displaystyle n} n) the attacker can find {\displaystyle k={\frac {z-z'}{s-s'}}} k={\frac {z-z'}{s-s'}}. Since {\displaystyle s=k^{-1}(z+rd_{A})} s=k^{-1}(z+rd_{A}), the attacker can now calculate the private key {\displaystyle d_{A}={\frac {sk-z}{r}}} d_{A}={\frac {sk-z}{r}}. This implementation failure was used, for example, to extract the signing key used for the PlayStation 3 gaming-console.[2] Another way ECDSA signature may leak private keys is when {\displaystyle k} k is generated by a faulty random number generator. Such a failure in random number generation caused users of Android Bitcoin Wallet to lose their funds in August 2013.[3] To ensure that {\displaystyle k} k is unique for each message one may bypass random number generation completely and generate deterministic signatures by deriving {\displaystyle k} k from both the message and the private key.[4]

## Signature verification algorithm
For Bob to authenticate Alice's signature, he must have a copy of her public-key curve point {\displaystyle Q_{A}} Q_{A}. Bob can verify {\displaystyle Q_{A}} Q_{A} is a valid curve point as follows:

Check that {\displaystyle Q_{A}} Q_{A} is not equal to the identity element {\displaystyle O} O, and its coordinates are otherwise valid
Check that {\displaystyle Q_{A}} Q_{A} lies on the curve
Check that {\displaystyle n\times Q_{A}=O} n\times Q_{A}=O
After that, Bob follows these steps:

Verify that {\displaystyle r} r and {\displaystyle s} s are integers in {\displaystyle [1,n-1]} [1,n-1]. If not, the signature is invalid.
Calculate {\displaystyle e={\textrm {HASH}}(m)} e={\textrm {HASH}}(m), where HASH is the same function used in the signature generation.
Let {\displaystyle z} z be the {\displaystyle L_{n}} L_{n} leftmost bits of {\displaystyle e} e.
Calculate {\displaystyle w=s^{-1}\,{\bmod {\,}}n} w=s^{-1}\,{\bmod {\,}}n.
Calculate {\displaystyle u_{1}=zw\,{\bmod {\,}}n} u_{1}=zw\,{\bmod {\,}}n and {\displaystyle u_{2}=rw\,{\bmod {\,}}n} u_{2}=rw\,{\bmod {\,}}n.
Calculate the curve point {\displaystyle (x_{1},y_{1})=u_{1}\times G+u_{2}\times Q_{A}} (x_{1},y_{1})=u_{1}\times G+u_{2}\times Q_{A}.
The signature is valid if {\displaystyle r\equiv x_{1}{\pmod {n}}} r\equiv x_{1}{\pmod {n}}, invalid otherwise.
Note that using Shamir's trick, a sum of two scalar multiplications {\displaystyle u_{1}\times G+u_{2}\times Q_{A}} u_{1}\times G+u_{2}\times Q_{A} can be calculated faster than two scalar multiplications done independently.[5]
